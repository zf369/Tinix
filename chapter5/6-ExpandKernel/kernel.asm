; ==========================================
; kernel.asm
; 重新设置了GDT，并且进行了跳转
;
; 编译链接方法(必须在linux下执行ld，但是生成可执行文件在linux下也不能执行了，因为这段汇编代码在linux下执行没有效果。):
; 注意入口地址030400h是我们在连接时指定的.  
; ld -s -Ttext 0x30400 -o kernel.bin kernel.o  
;
; [root@XXX XXX]# nasm -f elf kernel.asm -o kernel.o
; [root@XXX XXX]# nasm -f elf string.asm -o string.o
; [root@XXX XXX]# nasm -f elf klib.asm -o klib.o
; [root@XXX XXX]# gcc -c -m32 -fno-builtin -o start.o start.c
; [root@XXX XXX]# ld -m elf_i386 -s -Ttext 0x30400 -o kernel.bin kernel.o string.o start.o klib.o
; [root@XXX XXX]# 
; ==========================================

; a equ 8  jmp a:b 这里的8指的是偏移，即相对于GDT首地址的偏移是8个字节。
; 一个段描述符就是8个字节，所以这个selector就是第二个段的selector
SELECTOR_KERNEL_CS    equ    8

; 导入start.c中的函数
extern cstart

; 导入start.c中定义的全局变量
extern gdt_ptr


; --------------------------------- BSS ---------------------------------
; bssBSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。
; 注意和数据段的区别，BSS存放的是未初始化的全局变量和静态变量，数据段存放的是初始化后的全局变量和静态变量。

[section .bss]

;  "RESB", "RESW", "RESD", "RESQ" and "REST"被设计用在模块的 BSS 段中：
; 它们声明未初始化的存储空间。每一个带有单个操作数，用来表明字节数，字数，或双字数或其它的需要保留单位。
StackSpace    resb    2 * 1024    ; 保留2k的栈空间
StackTop:                         ; 栈顶


; --------------------------------- 代码段 ---------------------------------
[section .text]

global _start    ; 我们必须导出 _start 这个入口，以便让链接器识别。

_start:
    
    ;***************************************************************
    ; 内存看上去是这样的：
    ;              ┃                                    ┃
    ;              ┃                 .                  ┃
    ;              ┃                 .                  ┃
    ;              ┃                 .                  ┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;              ┃■■■■■■■■■■■ Page  Tables ■■■■■■■■■■■┃
    ;              ┃■■■■■■■■■■■(大小LOADER决定)■■■■■■■■■■┃
    ;    00201000h ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃ PageTblBase
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;    00200000h ┃■■■■■■■■■ Page Directory Table ■■■■■┃ PageDirBase  <- 2M
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
    ;       F0000h ┃□□□□□□□□□□□□ System ROM □□□□□□□□□□□□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
    ;       E0000h ┃□□□□□ Expansion of system ROM □□□□□□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
    ;       C0000h ┃□□□□□Reserved for ROM expansion□□□□□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃ B8000h ← gs
    ;       A0000h ┃□□□□□ Display adapter reserved □□□□□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
    ;       9FC00h ┃□□ extended BIOS data area (EBDA) □□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;       90000h ┃■■■■■■■■■■■■■ LOADER.BIN ■■■■■■■■■■■┃ somewhere in LOADER ← esp
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;       80000h ┃■■■■■■■■■■■ KERNEL.BIN ■■■■■■■■■■■■■┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;       30000h ┃■■■■■■■■■■■■■■ KERNEL ■■■■■■■■■■■■■■┃ 30400h ← KERNEL 入口
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃                                    ┃
    ;        7E00h ┃              F  R  E  E            ┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■┃
    ;        7C00h ┃■■■■■■■■■■■ BOOT  SECTOR ■■■■■■■■■■■┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃                                    ┃
    ;         500h ┃              F  R  E  E            ┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□┃
    ;         400h ┃□□□ ROM BIOS parameter area □□□□□□□□┃
    ;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ;              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
    ;           0h ┃◇◇◇◇◇◇◇◇◇◇ Int  Vectors ◇◇◇◇◇◇◇◇◇◇◇◇┃
    ;              ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛ ← cs, ds, es, fs, ss
    ;
    ;
    ;       ┏━━━┓            ┏━━━┓
    ;       ┃■■■┃ Tinix Used ┃□□□┃ 不能使用的内存
    ;       ┗━━━┛            ┗━━━┛
    ;       ┏━━━┓            ┏━━━┓
    ;       ┃   ┃ free       ┃◇◇◇┃ 可以覆盖的内存
    ;       ┗━━━┛            ┗━━━┛
    ;
    ;***************************************************************
    ; GDT 以及相应的描述符是这样的：
	;
	;		                    Descriptors                      Selectors
	;              ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
	;              ┃         Dummy Descriptor           ┃
	;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
	;              ┃         DESC_FLAT_C    (0-4G)      ┃         8h = cs
	;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
	;              ┃         DESC_FLAT_RW   (0-4G)      ┃        10h = ds, es, fs, ss
	;              ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
	;              ┃         DESC_VIDEO                 ┃        18h = gs
	;              ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
	;
	; 注意! 在使用 C 代码的时候一定要保证 ds, es, ss 这几个段寄存器的值是一样的
	; 因为编译器有可能编译出使用它们的代码, 而编译器默认它们是一样的. 比如串拷贝操作会用到 ds 和 es.
    ;***************************************************************	

    ; 转移esp, 将esp从Loader中挪到kernel中
    mov    esp, StackTop    ; 栈在BSS段中

    ; 保存gdt寄存器到[gdt_ptr], gdt_ptr是一个数组，gdt_ptr就是这个数组的首地址
    ; SGDT/SIDT - 存储全局/中断描述符表格寄存器
    ; 将全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR) 中的内容存储到目标操作数。
    ; 目标操作数是指定 6 字节内存位置。
    sgdt   [gdt_ptr]
    
    mov    ah, 0Ch                         ; 0000: 黑底    1111: 白字
    mov    al, 'A'
    mov    [gs:((80 * 5 + 39) * 2)], ax    ; 屏幕第 1 行, 第 39 列。

    ; cstart中改变了gdt_ptr，让它指向新的GDT 
    call   cstart

    mov    ah, 0Ch                         ; 0000: 黑底    1111: 白字
    mov    al, 'B'
    mov    [gs:((80 * 5 + 41) * 2)], ax    ; 屏幕第 1 行, 第 39 列。

    ; 重新设置GDT
    lgdt   [gdt_ptr]

    ; “这个跳转指令强制使用刚刚初始化的结构”
    jmp    SELECTOR_KERNEL_CS:csinit

csinit:

	; 将栈顶的双字 (POPFD)（如果当前操作数大小属性为 32）弹出，并将它的值存储到 EFLAGS 寄存器，
	; 或是将栈顶的字（如果操作数大小属性为 16）弹出，并将它存储到 EFLAGS 寄存器的低 16 位（即 FLAGS 寄存器）。
	; 这些指令执行 PUSHF/PUSHFD 指令的逆操作。
    push    0
    popfd    ; Pop top of stack into EFLAGS

    ; HLT 执行操作后, 使机器暂停工作, 使处理器CPU处于停机...
    hlt



