; ==========================================
; syscall.asm
; 通过中断调用系统API函数，通过该函数可以调用内核实现的函数
; ==========================================

%include "sconst.inc"

; 中断向量号
INT_VECTOR_SYS_CALL equ 0x90

; _NR_get_ticks是该接口要调用的内核函数在 global.c 中 sys_call_table 的序号
_NR_get_ticks       equ 0

_NR_write           equ 1


global get_ticks    ; 导出 get_ticks 作为系统函数调用接口
global write

bits 32

[section .text]

; 注意：dx 的值在 save() 中被改变，所以传递参数不能使用 edx！

; ====================================================================================
;                                   get_ticks
; ------------------------------------------------------------------------
; 作用：调用内核函数，获取当前ticks
; ====================================================================================
get_ticks:
    mov    eax, _NR_get_ticks    ; 将system call的序号放到eax中

    int    INT_VECTOR_SYS_CALL   ; 产生中断，进入内核执行系统调用

    ret

; get_ticks 结束 =========================================================================




; ====================================================================================
;                          void write(char* buf, int len);
; ------------------------------------------------------------------------
; 作用：调用内核函数，将buf输出到控制台
; ====================================================================================
write:
    mov    eax, _NR_write       ; 将system call的序号放到eax中

    mov    ebx, [esp + 4]       ; buf >>>>> ebx
    mov    ecx, [esp + 8]       ; len >>>>> ecx

    int    INT_VECTOR_SYS_CALL   ; 产生中断，进入内核执行系统调用

    ret

; write 结束 =========================================================================